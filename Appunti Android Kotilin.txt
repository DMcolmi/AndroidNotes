View Binding: (binding views to code)
View Binding permette di accedere alle 'viste' (layout) all'interno del codice.
View Binding genera delle classi .kt per ogni layout file .xml. (qelli dentro la cartella layout?)
tramite questa classe, viene fatto l'inflate del layout nella classe .kt, dopo di che tramite l'oggetto binding è possibile accedere/riferirsi a tutte le viste che hanno un @ID dentro il layout .xml 
in build.gradle:
buildFeatures {
	viewBindig = true
}

poi nelle classi .kt Activity è possibile fare:				
val binding = NomeActivityInCamelCaseBinding.inflate(layoutInflater) 
//(nota: il nome della classe binding 'NomeActivityInCamelCaseBinding' è creato in automatico, per ciascun .xml come: Nome Activity .xml In Camel Case + parola Binding)
setContentView(binding.root)

questo fa 2 cose:
1) assegna alla classe Activity.kt il layout.xml (es, activity_main.xml, il fatto che si chiamino emtrambi (.kt e .xml) activity è inrilevante)
	una volta assegnato suppongo lo 'avvii' facendo setContetView(binding.root). 
	Nota che spesso i nomi delle classi e dei layout a cui si riferiscono sono 'capovolti' e nei layout in snake case mentre le calssi in camel case (es LetterListFragment.kt, fragment_letter_list.xml)
2) si crea la variabile 'var binding' che permette di accedere agli elementi dentro la vista .xml (o layout, come si chiama?) ad sempio con binding.recyclerView
	es. binding.nomeTextView.text = getString(R.string.chiave)
-----------------------------------------------
RecyclerView 
1)nel app-level build.gradl aggiungere la dipendenza:
	implementation("androidx.recyclerview:recyclerview:1.2.1")
2)in un layout.xml, all'interno dei due tag <layout e <.. .ConstraintLayout aggiungere un RecyclerView:
		<androidx.recyclerview.widget.RecyclerView
			android:id="@+id/photos_grid"
			android:layout_width="0dp"
			android:layout_height="0dp"
			android:padding="6dp"
			app:layoutManager="androidx.recyclerview.widget.GridLayoutManager"
			app:layout_constraintBottom_toBottomOf="parent"
			app:layout_constraintLeft_toLeftOf="parent"
			app:layout_constraintRight_toRightOf="parent"
			app:layout_constraintTop_toTopOf="parent"
			app:spanCount="2"
			tools:itemCount="16"
			tools:listitem="@layout/grid_view_item"/>
		</androidx.constraintlayout.widget.ConstraintLayout>
	</layout>
3)implementare l'adapter

a)"Adapter"-utilizzato per la rappresentazione di liste statiche

TODO!!!!!!!!!!!!!!!

"ListAdapter"-utlizzato per rappresentare liste che possono variare.
utilizza un 'AsyncListDiffer' per determinare quali valori della lista sono variati in modo da aggiornare solo quelli.
1)creare un file .kt NomeParalteAdapter
	-dentro il file, creare una classe 'NomeParlanteAdapter'
	-la classe 'NomeParalteAdapter' estende ListAdapter che ha due generici.
		a)il primo è la classe che deve essere rappresentata (es una Entity del DB: ClasseEntity)
		b)il secondo è una classe di tipo ViewHolder per ... (definita dentro l'adapter NomeParalteAdapter) es NomeParlanteAdapter.ClasseViewHolder
		c)nel costruttore li ListAdapter si passa una classe 'DiffCallback'
		d)anche la classe NomeParlanteAdapter ha un parametro, 'onItemClicked()' 
			NOTA BENEEE:
		private val onItemClicked: (ClasseEntity) -> Unit
		questo parametro è una 'lambda expression'! 
		ha un parametro di input di tipo 'ClasseEntity', (al quale nella lambda ci si riferisce con it)
		e come output ha un valore di tipo Unit (sarebbe il void di Java, ovvero non ritorna una mazza) (l'id di una vista)

	class NomeParlanteAdapter(private val onItemClicked: (ClasseEntity) -> Unit) : ListAdapter<ClasseEntity, NomeParalteAdapter.ClasseViewHolder>(DiffCallback)

2)classe di tipo "ViewHolder" (es ClasseViewHolder) che implementa RecyclerView.ViewHolder e che prende come parametro un oggetto binding della vista (item) di cui è composto il RecyclerView
	all'interno della classe implementare la funzione bind() che prende in input un parametro di tipo es ClasseEntity e tramite l'oggetto di binding associa l'oggetto alla vista item del RecyclerView
	class ClasseViewHolder(private var binding: NomeVistaItemBinding): RecyclerView.ViewHolder(binding.root) {
		bind(classeEntity: ClasseEntity) {
			binding.vista.property =  classeEntity.property
			ecc.. (richimare binding.executePendingBindings() se l'oggetto arriva da un API?)
		}
	}
3)fare l'override del metodo onCreateViewHolder() che prende in input a)un parametro di tipo ViewGroup b)il viewType, un Int c)e che restituisce un oggetto ViewHolder 
		override fun onCreataViewHolder(parent: ViewGroup, viewType: Int): ClasseViewHolder {..
	all'interno del metodo onCreataViewHolder() 
		1) si crea un oggetto 'ViewHolder' passando al costruttore un binding del tipo VistaItemBinding su cui viene richiamato il metodo inflate
		2) tramite l'oggetto ViewHolder istanziato si setta al intemView (che cavolo è? una property ereditata dalla classe viewHolder ?)
			un clickListener { per richiamare il metodo onItemClicked che viene passato all'adapter
		3) si restituisce l'oggetto ViewHolder
		
		override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ClasseViewHolder {
			val viewHolder = CalsseViewHolder(
			   VistaItemBinding.inflate(
				   LayoutInflater.from( parent.context),
				   parent,
				   false
			   )
		   )
		   viewHolder.itemView.setOnClickListener {
			   val position = viewHolder.adapterPosition
			   onItemClicked(getItem(position))
		   }
		   return viewHolder
		}
4)fare l'override del metodo 'onBindViewHolder(holder: ClasseViewHolder, position: Int) {..' in cui 
	a)tratmite il metodo getItem() si recupera l'oggetto di tipo ClasseEntity
	b)si richiama il metodo bind() sul oggetto CalsseViewHolder passando l'oggetto ClasseEntity
	onBindViewHolder(holder: ClasseViewHolder, position: Int) {
		val classeEntity: ClasseEntity = getItrem(position)
		holder.bind(classeEntity)
	}
5)'DiffCallback' creare un 'companion object' che contiene al suo interno un istanza DiffCallback
	istanziare l'oggetto tramite DiffUtil.ItemCallback<ClasseEntity>() { passando come parametro dentro <> il tipo dell'oggetto da mettere nel RecyclerView
	implemetare, facendo l'override, i metodi 'areItemTheSame(oldItem: ClasseEntity, newItem:classeEntity): Boolean {..' e 'areContentsTheSame(oldItem: ClasseEntity, newItem:classeEntity): Boolean {..'
	companion object {
		private val DiffCallback = object : DiffUtil.ItemCallback<ClasseEntity>() {
			override fun areItemTheSame(oldItem: ClasseEntity, newItem:classeEntity): Boolean {
				return oldItem.Id == newItem.Id
			}
			override fun areContentsTheSame(oldItem: ClasseEntity, newItem:classeEntity): Boolean {
				return oldItem == newItem
			}
		}
	}
-----------------------------------------------
un altro modo per ottenere l'oggetto di binding è il seguente:
binding = NomeLayoutXmlInCamelCaseBinding.inflate(inflater, container, false)
non ho idea cosa siano questi:inflater, container, false - in questo caso era usato dentro il metodo onCreateView(..) di un fragment ed erano passati al costruttore
-----------------------------------------------

il get() vuol dire che la proprietà è 'get only', una volta che viene assegnata non (gli?) si può assegnare a qualcos'altro
private val binding get() = _binding!!
-----------------------------------------------
per settare l'optionMenu (app bar - action bar)
se è un fragment, richiamare setHasOptionMenu(true) dentro il metodo onCreate(..)
poi all'interno
1)assegnare il layout del menu:
inflater.inflate(R.menu.layout_menu,menu)
2) volendo si prende l'item e gli si assegna un icona
val layoutButton = menu.findItem(R.id.action_switch_layout)

//OLD
in unca classe activity.kt fare l'override dei metodi:
1)onCreateOptionsMenu 2)onOptionsItemSelected
    override fun onCreateOptionsMenu(menu: Menu?): Boolean {
        menuInflater.inflate(R.menu.layout_menu,menu)
        val layoutButton = menu?.findItem(R.id.action_switch_layout)
        setIcon(layoutButton)
        return true
    } 
	
//NEW
in unca classe activity.kt override del metodo onCreate(..), dentro ottenere in reference navHostFragment, inizializzare navController (dichiarato lateinit all'inizio della classe)
e passare il navController al metodo di setup:
        val navHostFragment = supportFragmentManager.findFragmentById(R.id.nav_host_fragment) as NavHostFragment
        navController = navHostFragment.navController
        setupActionBarWithNavController(navController)
per settare il navigate UP (sarebbe il pulsante <- che si trova nella barra in alto a sx, ovvero nel optionMenu), fare l'override del metodo onSupportNavigateUp(..)
    override fun onSupportNavigateUp(): Boolean {
        return navController.navigateUp() || super.onSupportNavigateUp()
    }
per settare il titolo dell'opion menu è possibile, nav_graph.xml, settare l'attributo android:label="@string/chiave" per ciascun fragment
-'ricaricare l'optionMenu'
	per ricaricare l'optin menu (es a seguito di un cambio di configurazione tramite SettingsDataSotre, richiamare la funzione invalidateOptionMenu() sul activity
		activity?.invalidateOptionMenu()
-----------------------------------------------
Jetpack Navigation Component, si compone di: 1)Navigation Graph 2)NavHost 3)NavController

import necessari per l'utilizzo del Jetpack Navigation Component:
	- nel project-lavel build.gradle impostare nav_version equal to 2.3.1
	buildscript {
    ext {
        ..
        nav_version = "2.3.1"
	- nel app-level build.gradle aggiungere:
		implementation "androidx.navigation:navigation-fragment-ktx:$nav_version"
		implementation "androidx.navigation:navigation-ui-ktx:$nav_version"
	- per usare il Safe Args Plugin nel top level build.gradle aggiungere nelle dependencies:
		dependencies {
			..
			classpath "androidx.navigation:navigation-safe-args-gradle-plugin:$nav_version"
	- nel app-level build.gradle aggingere nei plugins
		id 'androidx.navigation.safeargs.kotlin'
	
1) activity_main.xml
	- in activity_main.xml, (il layout a cui punta la classe MainActivity.kt) dentro il FrameLayout, aggiungere il <..FragmentContainerView (questo genererà un oggetto navController ..? il quale verrà poi utilizzato per spostarsi tra i vari fragment)
	- settare un id , chiamato ad esempio nav_host_fragment (a cui si farà poi riferimento nel ........MainActivity.kt?........)
	- per permettere al FragmentContainerView di navigare tra i diversi fragment, settare (altrimenti per settare un fragment fisso si può settare direttamente la classe .kt completa di pkg):
		android:name="androidx.navigation.fragment.NavHostFragment"
	- per permettere al FragmentContainerView di interagire con la gerarchia di navigazione (es andare al fragement precedente cliccando il bottone indietro), aggiungere
		app:defaultNavHost="true"
	- aggingere l'attributo navGraph, che punta a un .xml dove sono specificati i fragment (e il il modo in cui si può navigare tra loro) a cui il FragmentContainerView può navigare
		app:navGraph="@navigation/nav_graph"
	
2) nav_graph.xml (file > New > Androind Resource File. il nome deve essere lo stesso usato nell attributo app:navGraph messo nel FragmentContainerView. settere il Resource Type = Navigation)
	- con il pulsante 'New Destination' aggiungere i fragment precedentemente creati
	- per creare 'navigation actions' tra due destinazioni (fragment) trascinare dal cerchio del fragment di origine al fragment di destinazione. viene creata un action con nome action_fragmentDiPartenza_to_fragmentDiDestinazione
	se si crea una action per tornare indientro, ad esempio action_fragmentDiDestinazione_to_fragmentDiPartenza, una nuovo fragment di partenza viene aggiunto allo stack di quelli già creati, non si ritorna al fragment che era già stato creato inizialmente
		per far si che i fragmet vengano distrutti, settare nella navigation action (o utlilizzando il menu):
	1)	app:popUpTo="@id/fragmentDiPartenza" -> questo permette di distruggere tutti i fragment fino a quello di partenza (escluso). ora si hanno il fragment di partenza creato inizialmente e il nuovo fragment di partenza che si crea quando si richiama action_fragmentDiPartenza_to_fragmentDiDestinazione
	2)	app:popUpToInclusive="true" -> questo attributo fa si che anche il fragment creato all'inizio venga distrutto. in questo modo rimane unicamente il fragment di partenza appena creato. in questo modo, se il fragement è quello di partenza, con il pulsante indietro si esce dall'applicazione
	- per aggiungere un argomento ('Arguments') a un fragment di destinazione, con il tasto + si aggiunge l'argomento specificando il nome e il tipo
	- per settare la destinazione iniziale che verrà utilizzata dal FragmentContainerView, selezionare il fragment desiderato e cliccare sull'icona con la casa
	- per mostrare il titolo del fragment aggiungere l'attributo android:label="@string/chiave"
	
3) navigare tra fragment
	- (ad esempio questo si può usare dentro un adapter, nel metodo onBindViewHolder(..), aggiungendo un holder.button.setOnClickListener { })
	 val action = ClasseFragmentDiPartenzaDirections.actionFragmentDiPartenzaToFragementDiDestinazione(parametro (quello settato nel fragment di destinazione nel nav_graph.xml) = holder.button.text.toString() (in questo caso il parametr era la lettera sopra il bottone))
	 holder.view.findNavController().navigate(action)
	 
	 call the NavController's navigate() method to swap the fragment that's displayed
	 la classe ClasseFragmentDiPartenzaDirections (notere che il nome è il nome della classe fragment + la parola Directions) è generata automaticamente, permette di adare dal fragment di partenza a tutti quelli settati come destinazione nel nav_graph.xml
	 il metodo actionFragmentDiPartenzaToFragementDiDestinazione(..) della classe ClasseFragmentDiPartenzaDirections, è genreato automaticamente dopo aver disegnato la freccia nel nav_graph.xml. prende come parametro l'argoment settato nel fragment di destinazione

	un altro modo per navigare, ad esempio dentro un fragment si puo richiamare:
	findNavController().navigate(R.id.action_fragmentDiPartenza_to_fragementDiDestinazione)

4) configurare la classe MainActivity.kt per far partire il controller con il primo fragment:
	- creare la proprietà in cima alla classe settandola lateinit: private lateinit var navController: NavController
	- all'interno del metodo onCreate, valorizzare la proprietà navController dichiarata sopra, passando l'id del <..FragmentContainerView utilizzato dentro al main_activity.xml (o il layout a cui si sta facendo riferimento) 
	dentro il quale è settato l'attributo 'app:navGraph="@navigation/nome_nav_graph"' che fa riferimento al nav_graph.xml dentro la folder 'navigation' che contiene le logiche di navigazione tra i fragment:
	
		val navHostFragment = supportFragmentManager.findFragmentById(R.id.nav_host_fragment) as navHostFragment
		navController = navHostFragment.navController
		
	- per attivare i pulsanti della action bar, richiamare il metodo:
		setupActionbarWithNavController(navController)
	- per gestire il pulsante 'up' (indietro..? nell'optionMenu..?) fare l'override del metodo onSupportNavigateUp()
		override fun onSupportNavigateUp(): Boolean {
		   return navController.navigateUp() || super.onSupportNavigateUp()
		}
5) passaggio di argomenti a un fragment di destinazione
	- nella classe FragmentDiDestinazione.kt, dichiarare una la proprieta lateinit (a cui poi associare l'argomenti passato a fragment): private lateinit var letterId: String
	- dentro il metodo overrideato onCreate, recuparare il valore della proprietà dal argomento:
		arguments?.let{
			letterId = it.getString(LETTER).toString()
		}
	- poi si può usare la propretà dove si vuole, avendola usata a livello di classe
-----------------------------------------------
in unca classe, mettendo il blocco init{..}, le istruzioni al suo interno vengono eseguite quando viene creato l'oggetto.
nota: se si fa riferimento a property di classe che devono essere inizializzate, il blocco init va messo DOPO l'inizializzazione
-----------------------------------------------
ViewModel
The ViewModel is a part of the Android Architecture Components and the app data saved within the ViewModel is retained during configuration changes. 
To add a ViewModel to your app, you create a new class and extend it from the ViewModel class.
Shared ViewModel (istanziato con 'by activityViewModels()' al posto di 'by viewModels()') is used to save the app's data from multiple fragments in a single ViewModel. Multiple fragments in the app will access the shared ViewModel using their activity scope.

ViewModel è responsabile per processare e contenere i dati che vengono utilizzati dall UI
1) dentro il build.gradle app level serve il seguente import:
	implementation 'androidx.lifecycle:lifecycle-viewmodel-ktx:2.3.1'
2) creare una classe .kt ClasseViewModel che estende ViewModel:
	class ClasseViewModel: ViewModel(){..
3) creare un reference (oggetto) dentro il componente 'UI controller' (activity o fragmet) che utilizzerà la classe ViewModel:

	private val viewModel: ClasseViewModel by viewModels() (--> dubbio, cos'è sto viewModels()????)
	
si usa il 'by viewModels()' che è un 'Kotlin property delegate'
Kotlin property delegate:
	in Kotlin:
	per le property var, getter e setter sono creati automaticamente in un altra classe delegata.
	per le property val, sono creati solo i getter automaticamente in una classe delegata.
	una 'delegate property' è definita specificando utilizzando il 'by' e una istanza della classe delegata:
	var <property-name>: <property-type> by <delegate-class>()
	se il reference della classe ViewModel si crea richiamando il costruttore (private val viewModel = ClasseViewModel()), quando il componente 'UI controller' (activity o fragment) viene distrutto e ricreato, verrebbe ricreata anche l'istanza del ViewModel perdendo cosi i dati precedenti.
	invece si ottiene l'istanza della classe ClasseViewModel tramite la classe delegata viewModels() che salva l'istanza e restituisce la stessa istanza anche dopo cjhe il componente UI viene distrutto e ricreato, in questo modo i dati non vengono persi
	
	se l'istanza viewModel deve essere connfivisa da piu fragment, al posto di utilizzare il 'by viewModels()' si utilizza il 'by activityViewModels()'
	in questo modo l'istanza rimarrà la stessa in tutti i fragment che fanno rirerimento a quell'activity:
	by viewModels() gives you the ViewModel instance scoped to the current fragment. This will be different for different fragments.
	by activityViewModels() gives you the ViewModel instance scoped to the current activity. Therefore the instance will remain the same across multiple fragments in the same activity.
		
4) dentro la classe ViewModel, le proprietà (property) sono da rendere accessibili tramite Backing property.
	questo permette di accedere al valore senza poterlo modificare. i dati modificabili dentro classi ViewModel devono sempre essere private e l'accesso fatto tramite 'Backing property'
	Backing property:
	private var _nomeProperty = 0 //la property deve essere inizializzata
	val nomeProperty: Tipo //in Kotlin di dafault se non è indicato il modificatore di accesso è sotto inteso public
		get() = _nomeProperty
-) dentro una classe che implementa ViewModel, il metodo onCleared(){..} viene richiamato prima che l'oggetto ViewModel venga distrutto
-----------------------------------------------
implemetare una finestra di Dialog (MaterialAlertDialog)
1)creare una funzione che andra a creare il dialog quando richiamata. dato che è un componente UI, va inserita dentro un 'UI controller', in questo caso un fragment
2)staziare in oggetto dialog con il costruttore MaterialAlertDialogBuilder(context :Context)
	per recupaera l'oggetto di context dentro il fragemnt, si usa il metodo requiredContext():
	val dialog = MaterialAlertDialogBuilder(requiredContext())
	
	il context si riferisce al contesto dello stato corrente di un applicazione, activity o fragment.
	il context contiene le informazioni relative alla applicazione, activity o fragment.
	
3)settare il titolo del Dialog:	dialog.setTitle(getString(R.string.chiave))
4)settare il message del dialog: dialog.setMessage(getString(R.string.chiave, valore))
5)impedire che il dialog si chiuda con il tasto indietro: dialog.setCancelable(false)
6)settare i due pulsanti 'NegativeButton' e 'PositiveButton'.
	dialog.setNegativeButton(getString(R.string.chiave)) {_,_ -> funzioneDaRichiamare()}
	dialog.setPositiveButton(getString(R.string.chiave)) {_,_ -> funzioneDaRichiamare()}
	
	NOTA: la funzione setNegativeButton prede 2 parametri: una stringa, una lambda. la lambda è stata spostata fuori dalle parentesi, questo è chiamato come 'trailing lambda syntax':
	dialog.setNegativeButton(getString(R.string.chiave), {_,_ -> funzioneDaRichiamare()})  DIVENTA -> dialog.setNegativeButton(getString(R.string.chiave)) {_,_ -> funzioneDaRichiamare()}
	NOTA2: la lambda ha due argomenti, {dialog, which -> funzioneDaRichiamare()} che non sono utilizzati e sono sostituiti da _
	{dialog, which -> funzioneDaRichiamare()} DIVENTA -> {_, _ -> funzioneDaRichiamare()}
7)rendere il dialog visibile: dialog.show()
-----------------------------------------------
Setup componenti fragment: dopo aver fatto 'collegato' le due componenti del fragment (ca classe .kt e la vista .xml) all'interno del onCreateView(..) attraverso l'inflete, ovvero: binding = NomeActivityO FragmentXmlInCamelCaseBinding.inflate(infalter, container, false)
il setup delle parti che compongono il layout .xml viene fatto all'interno del metodo onViewCreated(..) (impostare onClickListener sui pulsati, impostare il testo dei text field, ..) ad esempio:
binding.submit.setOnClickListener { onSubmitWord() }
binding.score.text = getString(R.string.score, 0)
-----------------------------------------------
LiveData class:
la classe LiveData è una 'observable data holder class' che è 'lifecycle aware':
- LiveData contiene dati, è una classe wrapper che può contenere qualsiasi tipo di dato
- Livedata è un 'observable', questo vuol dire che ogni 'observer' viene notificato ogni volta che avviene un cambiamento nell'oggetto LiveData
- Livedata è 'lifecyclae aware'. l'oggetto LiveData è collegato (ha un reference) a degli observer che sono collegati a dei 'LifecycleOwner'(un activity o fragment).
	l'oggetto LiveData aggiorna gli observer solo se sono in uno stato 'attivo' come STARTED o RESUMED.
- lo scopo di un oggetto LiveData è di non dover richiamare in diversi punti del cofice le fuzioni che gestiscono l'aggiornamento delle proprietà collegate ai componendi del layout (ad esempio il contenuto di un campo TextView)
  al posto di richiamare l'aggiornamento step by step, l'oggetto LiveData, ad ogni modifica dei dati che contiene, notifica la classe 'UI controller' (activity o fragmet) che va a effettuare gli aggiornamenti
1)Per utilizzare la classe LiveData all'interno di un ViewModel, dichiarare le property con il tipo di dato MutableLiveData (settando al posto del generico l'effettivo tipo di dato della property), poi utilizzando la Backin property per accedere al valore della property senza poterlo modificare:
	private val _nomeProperty = MutableLiveData<TipoDato>()
	val nomeProperty; LiveData<TipoDato>
		get() = _nomeProperty
	Nota: val e non var perchè non cambierà il valore della property dentro la classe ViewModel ma cambierà dentro la classe MutableLiveData
2) per settare l'observer della property contenuta in LiveData (observable), all'interno della fragment.kt o  activity.kt ('UI controller' (activity o fragmet)) 
	richiamare il metodo observe() sulla property dichiarata di tipo LiveData (Backing property della MutableLiveData):
	viewModel.nomePropertyLiveData.observe(..)
	all'intenro del metodo observe passare 2 parametri:
	a) viewLifecycleOwner (rappresenta il lifecycle del Fragment's View, in quest modo l'oggetto LiveData sa quando il fragment è attivo per notificarlo)
	b) una 'lambda expression' che viene richiamata quando l'observer è notificato dal observable (LiveData), che ha un parametro di input (il nuovo valore aggiornato della property
		{newPropertyValue -> binding.idComponenteVista.text = getString(R.string.IdStringa, newPropertyValue)}
	viewModel.nomePropertyLiveData.observe(viewLifecycleOwner, {newPropertyValue -> binding.idComponenteVista.text = getString(R.string.IdStringa, newPropertyValue)})
-----------------------------------------------
Data Binding ('Data Binding Library' binding code to views (la novità)+ binding views to code)
es di 'Data Binding' in un file layout .xml (views e widget)
	android.text = "@{classeViewModel.nomeProperty}" (notare l'uso di @{})
il vantaggio di questo approccio è che evita di utilizzare i framework all'interno delle activity (come il LiveData??)

1)in build.gradle: (al posto di viewBindig = ..)
buildFeatures {
	dataBindig = true
}
plugins{
..
id 'kotlin-kapt'
}

2) convertire i layout .xml in 'data binding layout'
- includere i tag all'interno di un tag <layout>
- sotto il tag layout aggiungere il tag <data>
- spostare gli attributi xmlns:.. all'interno del tag <layout>
- questo può essere fatto automaticamente in un colpo solo, selezionando il promo tag, dalla lampadina scegliere 'convert to data binding layout'

3) utilizzando il 'Data Binding', l'oggetto 'binding' viene istanziato cosi: (diverso da view binding dove era binding = NomeLayoutXmlInCamelCaseBinding.inflate(infalter, container, false). nota, si può comunque continuare ad utilizzare questo)
es, in una classe fragment .kt, all'interno di onCreateView(..)
binding = DataBindingUtil.inflate(inflater, R.layout.nome_layout_es_fragment, container, false)

4) dentro il layout .xml, all'interno del tag <data> aggiungere per ogni viewModel a cui si deve accedere, un tag <variable con i seguenti attributi:
<data>
	<variable
		name="classeViewModel" (credo un nome che si vuole, si usa come riferimento)
		type="com.example.android.nomeApplicazione.ui..ClasseViewModel"> (il percorso del pkg della classe viewModel
</data>

5) per ogni property a cui si vuole accedere (NOTA: che non faccia già parte della classe ViewModel, ad esempio una costante definita in un altra classe. questa andrà poi inizializzata fentro onCreateView()) , dentro il tag <data> aggiungere un tag <variable:
	<variable
		name="nomeParlanteCheSiVuoleDareAllaProperty"
		type="tipoDellaProperty"> (es int)
		
6) nella classe fragment .kt in cui si è fatto il binding al layout .xml, inizializzare le variabili create tramite l'oggetto di binding
	(nota: sia della classe viewModel che contiene le property, sia per ogni property)
	binding.classeViewModel = viewModel (reference della classe ViewModel ottenuto con by viewModels()' che è un 'Kotlin property delegate')
	binding.nomeParlanteCheSiVuoleDareAllaProperty = viewModel.property
7) è necessario specificare all'oggetto di binding (quindi al layout .xml ?) chi è il 'LifecycleOwner', in modo tale che possa essere notificato dal LiveData quando c'è un cambiamento e quando il leyout è attivo:
	// Specify the fragment view as the lifecycle owner of the binding. This is used so that the binding can observe LiveData updates
	binding.lifecycleOwner = viewLifecycleOwner (è lo stesso che si usa quando si setta l'observe(..) su una property della classe ViewModel)
8) 'binding expression' vuol dire associare la vista del layout alla property tramite l'attributo, come android:text="@{classeViewModel.nomeProperty}"
	android:text="@{classeViewModel.nomeProperty}"
	per passare le property come parametri di risorse:
	android:text="@{@string/chiave(classeViewModel.nomeProperty)}"
-----------------------------------------------
Activity Lifecycle:
gli step di vita di un activity sono i seguenti:
inizialized ->1 created ->2 started ->3 RESUMED ->4 started ->5 created ->6 destroyed
(resumed è quando l'activity è visibile a schermo e l'utnete può interagire)
nel passaggio tra i vari step, i seguenti metodi sono richiamati
->1 onCreate() [is called once, just after the activity is initialized (when the new Activity object is created in memory]
->2 onRestart() + onStart() [After onStart() runs, your activity is visible on the screen. Unlike onCreate(), which is called ONLY ONCE to initialize your activity, onStart() can be called many times in the lifecycle of your activity]
->3 onResume() [to give the activity focus and make it ready for the user to interact with it.  is called at startup, even if there is nothing to resume]
->4 onPause() [the app no longer has focus]
->5 onStop() [the app is no longer visible on screen]
->6 onDestroy() [activity fully shut down and can be garbage-collected]
NOTA: onStart() and onStop() are called multiple times as the user navigates to and from the activity.

Fragment Lifecycle:
il life cycle di un fragment ha 5 stati, identificati dall'enumerazione Lifecycle.State:
INITIALIZED: A new instance of the fragment has been instantiated.
CREATED: The first fragment lifecycle methods are called. During this state, the view associated with the fragment is also created.
STARTED: The fragment is visible onscreen but does not have "focus", meaning it can't respond to user input.
RESUMED: The fragment is visible and has focus.
DESTROYED: The fragment object has been de-instantiated.

Metodi richiamati nei passaggi di stato del fragment riferiti al relativo stato:
CREATED
	onCreate(): The fragment has been instantiated and is in the CREATED state. However, its corresponding view has not been created yet.
	onCreateView(): This method is where you inflate the layout. The fragment has entered the CREATED state.
	onViewCreated(): This is called after the view is created. In this method, you would typically bind specific views to properties by calling findViewById().
STARTED
	onStart(): The fragment has entered the STARTED state.
RESUMED
	onResume(): The fragment has entered the RESUMED state and now has focus (can respond to user input).
STARTED
	onPause(): The fragment has re-entered the STARTED state. The UI is visible to the user
CREATED
	onStop(): The fragment has re-entered the CREATED state. The object is instantiated but is no longer presented on screen.
	onDestroyView(): Called right before the fragment enters the DESTROYED state. The view has already been removed from memory, but the fragment object still exists.
DESTROYED
	onDestroy(): The fragment enters the DESTROYED state.
-----------------------------------------------
costruttore parametrizzato per avviare associare una vista alla MainActivity.kt:
AppCompatActivity(@LayoutRes int contentLayoutId) which takes in a layout that will be inflated as part of super.onCreate(savedInstanceState).

codice nella classe MainActivity .kt che usa il costruttore:
class MainActivity : AppCompatActivity(R.layout.activity_main)

equivale al codice di seguto che usa il costruttore AppCompatActivity() di default senza parametro, la vista viene settata nel metodo onCreate(..):
class MainActivity : AppCompatActivity() {

   override fun onCreate(savedInstanceState: Bundle?) {
       super.onCreate(savedInstanceState)
       setContentView(R.layout.activity_main)
   }
}
-----------------------------------------------
Mostrare un 'Toast' a schermo:
Toast.makeText(context,"stringa da mostrare con $parametro per mostrare parametri", Toast.LENGTH_SHORT).show()
-----------------------------------------------
Apply scope function
apply è una 'scope function', permette di accedere alle proprietà dell'oggetto su cui viene richiamata senza dover ogni volta specificarne il nome
es. al posto di:
oggetto.proprieta1 = ..
oggetto.proprietaN = ..
si fa:
oggetto.apply{
	proprieta1 =
	..
}
-----------------------------------------------
'Listener Binding'
Listener bindings (passare data da layout xml a classi .kt(es viewModel))
il 'Listener bindings' sono lambda expression richiamate in concomitanza di un evento (es un onClick).
They are similar to method references such as textview.setOnClickListener(clickListener) but listener bindings let you run arbitrary data binding expressions.
queste lambda expression sono richiamate direttamente all'interno di layout .xml, la sintassi è la seguente:
"@{() -no parametri di input- -> classeViewModel.metodoDaRichiamare( -parametro, es- @string/chiave)}" 

es. all'interno di un <RadioButton
android:onClick="@{() -> classeViewModel.metodoDaRichiamare(@string/chiave)}" 

allo stesso modo si richiamano i metodi all'interno di classi .kt che non prendono paramenti in input, es dentro un <Button:
android:onClick="@{() -> nomeVariabileClasseKtDichiarataNelTagData.esempioMetodoDaRichiamare()}"
-----------------------------------------------
per checkare un RadioButton paragonando 2 campi del viewModel:
android:checked="@{orderViewModel.pickUpDate.equals(orderViewModel.dateOptions[2])}"
-----------------------------------------------
Date in Kotlin - come recuperare la data di oggi e trasformarla in stringa:
Android frameworks provides a class called SimpleDateFormat, 
a class for formatting and parsing dates in a locale-sensitive manner. 
It allows for formatting (date → text) and parsing (text → date) dates.


		//lista di date
		val options = mutableListOf<String>()

        //istanza di simplaDateFormat per formattare la data
        val formatter = SimpleDateFormat("E MMM d", Locale.getDefault())

        //istanza del calendario
        val calendar = Calendar.getInstance()

        //ripete per 4 volte:
        //aggiunge una data alla lista di date,
        //incrementa la data di un giorno
        repeat(4){
            options.add(formatter.format(calendar.time))
            calendar.add(Calendar.DATE, 1)
        }
-----------------------------------------------
Elvis Operator
The elvis operator (?:) means that if the expression on the left is not null, then use it. 
Otherwise if the expression on the left is null, then use the expression to the right of the elvis operator. eg:
quantity.value ?: 0 (if quantity.value is null then use 0)
-----------------------------------------------
LiveData transformation method
The LiveData transformation method(s) provides a way to perform data manipulations on the source LiveData and return a resulting LiveData object.
formattare un prezzo dentro un oggetto LiveData aggiungendo la valuta:
val price: LiveData<String> = Transformations.map(_price) { NumberFormat.getCurrencyInstance().format(it) }		
(dove _price è un MutableLiveData<Double>)
NB: non usare il get() = Trasf.., ma fere direttamente =, ovvero '..LiveData<String> = Transf..' altrimenti non funziona in alcuni casi sul format string (il caso in cui non mi funzionava era in un Inplicit Intent per mandare una mail
-----------------------------------------------
Tasks & back stack
Activities in Android exist within tasks.
A task is a collection of activities that the user interacts with when performing a certain job.
Activities are arranged in a stack, known as a back stack, where each new activity the user visits gets pushed onto the back stack for the task.
The back stack is useful for when the user wants to navigate backwards. Android can remove the current activity from the top of the stack, destroy it, and start the activity underneath it again.
back stack can also track the fragment destinations the user has visited.
The Navigation library allows you to pop a fragment destination off the back stack each time the user hits the Back button. This default behavior comes for free, without you needing to implement any of it. You would only need to write code if you need custom back stack behavior.
nel nav_graph.xml per ogni action:
app:popUpTo="@id/startFragment"
app:popUpToInclusive="true"
-----------------------------------------------
in una resource string come <string name="chiave">blabla %1$s \n %2$s</string>
$s inidca che il tipo di dato è una stringa, %d è in intero, \n va a capo
-----------------------------------------------
Intent (passare da un activity a un altra (?) o lanciare un altra app)
'implicit intent' (verso una risorsa esterna)
costruire un 'implicint intent':
	val intente = Intent(Intent.ENUM_IMPLICIT_INTENT).apply {
		type = "*/*"(????)
		putExtra(Intent.EXTRA_ENUM_RELATIVO_AL_IMPLICIT_INTENT_SCELTO, valorePassato)
		..
	}
lanciare un implicit intent:
check to see if there's an app that could even handle the implicit intent
Perform this check by accessing the PackageManager, which has information about what app packages are installed on the device. 
The PackageManager can be accessed via the fragment's activity, as long as the activity and packageManager are not null. 
Call the PackageManager's resolveActivity() method with the intent you created. 
If the result is not null, then it is safe to call startActivity() with your intent.

1) da documentazione
	if (intent.resolveActivity(packageManager) != null) {
        startActivity(intent)
    }
2) in esercizio fatto, partendo da un fragment:
	if (activity?.packageManager?.resolveActivity(intent, 0) != null) {
		startActivity(intent)
	}

-----------------------------------------------
'quantity strings'
1)nel string.xml utilizzare il tag <plurals:
	<plurals name="chiave">
			<item quantity="one">%d esempio</item>
			<item quantity="other">%d esempi</item>
	</plurals>
2) la stringa viene costruita rihiamando il metodo getQuantityString() e passando la chiave del <prlurals e due volta la quantità (una viene usata per decidere quale stringa mostrare, l'altra è quella che viene visualizzata)
	getQuantityString(R.plurals.chiave, 1, 1)
-----------------------------------------------
kotlin safe calls
safe calls vuol dire accedere a una proprietà con l'operatore '?.', 
1) è obbligatorio quando l'oggetto suò essere nullo 
2) in caso l'oggetto sia nullo ritorna null come valore della propretà a cui si sta cercando di accedere, se NON è nullo ritorna l'effettivo valore della proprietà
oggetto?.property
-----------------------------------------------
creare un Thread:
	val thread = Thread { qualsiasi cosa si vuole far fare al thread }
far partire il thread:
	thread.start()
-----------------------------------------------
->Coroutines<- https://github.com/Kotlin/kotlinx.coroutines/releases
	Coroutines provide a more flexible and easier way to manage concurrency (concetto simile a thread?)
STATE (continuations)
	key feature of coroutines is the ability to store STATE, so that they can be halted and resumed.
	The STATE is represented by 'continuations'.
	continuations allows portions of code to signal when they need to hand over control or wait for another coroutine to complete its work before resuming
Job
	(la creazione di una coroutine racchiude quel lavoro in un Job, a cancelable unit of work with a lifecycle, inside a CoroutineScope)
	A cancelable unit of work, such as one created with the launch() function.
CoroutineScope
	(is a context that enforces cancellation and other rules to its children and their children recursively)
	Functions used to create new coroutines such as launch() and async() extend CoroutineScope
	
	fun CoroutineScope.launch {
		context: CoroutineContext = EmptyCoroutineContext,
		start: CoroutineStart = CoroutineStart.DEFAULT,
		block: suspend CoroutineScope.() -> Unit
	}
	Fun CoroutineScope.async() {
		context: CoroutineContext = EmptyCoroutineContext,
		start: CoroutineStart = CoroutineStart.DEFAULT,
		block: suspend CoroutineScope.() -> T
	}: Deferred<T>
Nota: la coroutine si lancia con ad esempio GlobalScope (non con CoroutineScope, che sarà l'interfaccia?)
	async()
		la funzione async() ritorna un valore di tipo 'Deferred', un place older, il valore varrà assegnto a questo oggetto quando la funzione lo restituirà
		per recuperare il valore di ritonro, si richiama il metodo await() sull'oggetto di tipo Deferred es. oggetto.await()
		
	
Dispatcher
	(Dispatcher manages which backing thread the coroutine will use for its execution, removing the responsibility of when and where to use a new thread from the developer)
	Determines the thread the coroutine will use. The Main dispatcher will always run coroutines on the main thread, while dispatchers like Default, IO, or Unconfined will use other threads.
es creazione di una coroutine:
	GlobalScope.launch {
		qualisiasi istruzione che si vuole associare alla coroutine creata
	}
GlobalScope 
	allows any coroutines in it to run as long as the app is running (this is not recommended)
launch() { .. }
	(creates a coroutine from the enclosed code wrapped in a cancelable Job object. launch() is used when a return value is not needed outside the confines of the coroutine)
suspend
	suspend keyword (si mette prima di un metodo) Suspend signals that a block of code or function can be paused or resumed. es:
	suspend fun nomeFunzione() : tipoDiRitorno { 
		delay(3000)
		..
	}
runBlocking()
	fa partire (start) una nuova coroutine a blocca il thread corrente fino al suo completamento
	il thread principale viene messo in pausa fino a quando le due funzioni async non terminano???
	runBlocking() {
		async { funzione() }
        async { funzione() }
	}
-----------------------------------------------
Object declarations
object declaration in kotlin sono oggetti singleton, ovvero che si possono istanziare solo una volta.
sono thread safe e vengono istanziati al primo accesso (primo utlizzo di un metodo su quell'oggetto ??)
questi oggetti sono definiti con l'uso della parola chiave 'object'
	object NomeOggettoSingleton {
		fun nomeFunzioneDefinita(..) { ..
	}
per richiamare le funzioni si richiama direttamente la funzione sull'oggetto:
	NomeOggettoSingleton.nomeFunzioneDefinita(..)
-----------------------------------------------
Retrofit
una libreria per interfacciarsi con api REST
1)aggiungere le dipendenze nell'app-level gradle:
		// Retrofit 
		implementation "com.squareup.retrofit2:retrofit:2.9.0"
		// Retrofit with Moshi Converter
		implementation "com.squareup.retrofit2:converter-scalars:2.9.0"
	nell'app-level build gradle deve esserci il supporto a java 8
		compileOptions {
			sourceCompatibility JavaVersion.VERSION_1_8
			targetCompatibility JavaVersion.VERSION_1_8
		}
		kotlinOptions {
			jvmTarget = '1.8'
		}
2)creare un FILE NomeApiService.kt e definire una costante con l'URL di base del server:
		private const val BASE_URL = "https://.."
	creare un oggetto 'Retrofit' con un Retrofit builder:
		private val retrofit = Retrofit.Builder()
	è necessario associare all'oggetto retrofit un 'converter factory'. il converter definisce come gestire i dati che riceve dal server (es JSON) e cosa restituire (es String). es di converter è ScalarsConverter
		... = Retrofit.Builder()
			.addConverterFactory(ScalarsConverterFactory.create())
	aggiungere l'URI di base del server e richiamare il metodo build per completare l'oggetto retrofit
		... 
			.baseUrl(BASE_URL)
			.build()

3)creare un interfaccia NomeApiService in cui definire il metodo che Retrofit utilizza per comunicare con il server tramite HTTP request
		interface NomeApiService { ..
	dentro l'interfaccia definire la funzione che retrofit utilizza per comunicare con il server, specificando a)nome b)tipo di richiesta (es GET) c)endpoint (non serve specificare il primo /) d)tipo di ritorno
	NOTA BENE: definire il metodo 'suspend' in modo tale che possa essere richiamato all'intero di una coroutine
		@GET("endpoint")
		suspend fun nomeMetodo() :String
4)richiamare la funzione 'create()' su un oggetto Retrofit è costoso, l'applicazione necessita solo di un API Service, viene quindi creato un 'Object declaration'
		object NomeApi{..
	all'intereno di questo oggetto, creare una un oggetto retrofit di tipo NomeApiService, l'interfaccia creata in precedenza (si, un interfaccia (?) boh, sarà una cosa del framework retrofit)
	creare questo oggetto tramite lazy initialization, attraverso il costrutto 'by lazy {..}'
		val retrofitService :NomeApiService by lazy {
			retrofit.create(NomeApiService::class.java)
		}
5)utilizzare il retrofit service all'interdo di una classe ViewModel
	ogni classe che implementa ViewModel() ha una coroutine viewModelScope, questa viene utilizzata per richiamare le i metodi di retrofit e lanciarli in background (per fare questo i metodi di retrofit devono essere dichiarati susped)
	all'interno della classe ViewModel, dentro il metodo creato per recuperare i dati utilizzando retrofit, lanciare una coroutine:
	vievModelScope.launch{ 
		val result = NomeApi.retrofitService.nomeMetodo()
		..poi con il valore di ritorno fare quello che pare, es associarlo a una text view
	}
6)aggiungere i permessi per la connessione internet: nel AndroidManifest.xml, sotto il tag <manifest.. aggiungere:
	    <uses-permission android:name="android.permission.INTERNET"/>

Moshi
1)aggiungere le dipendenze nell'app-level gradle:
	implementation 'com.squareup.moshi:moshi-kotlin:1.9.3'
  sostituire le 2 implementation di retrofit inserite in precedenza con:
	// Retrofit with Moshi Converter
	implementation 'com.squareup.retrofit2:converter-moshi:2.9.0'
2)creare una classe .kt per mappare l'oggetto JSON restituito dall'API
	questa classe deve avere la keyword 'data' e le { devono essere sostituite con le (
	ci deve essere un campo per ogni 'chiave' dell'oggetto JSON e il tipo deve corrispondere
	se si vuole dare un nome diverso al campo da quello della chiave presente nel JSON, utilizzare l'annotazione sopra il campo in cui viene riportata la chiave corretta @Json(name = "chiave2")
	data class NomeClasseMappatura(
		val chiave1 :String
		@Json(name = "chiave2")
		val chiave2conNomeDiverso :String
	)
3)dentro il file NomeApiService.kt creato per implementare l'api, prima del oggetto Retrofit, creare un oggetto Moshi
	aggiungere KotlinJsonAdapterFactory() e richiamare il build()
	private val moshi = Moshi.Builder()
	.add(KotlinJsonAdapterFactory())
	.build()
4)sostituire il converter di retrofit con quello di Moshi passando l'oggetto moshi creato sopra (da ScalarsConverterFactory.create() a MoshiConverterFactory.create(moshi)
5)dentro l'interfaccia, sostituire il tipo di ritorno del metodo che Retrofit usa per comunicare con la classe 'data' creata per mappare le chiavi del JSON:
	@GET("endpoint")
		suspend fun nomeMetodo() :List<NomeClasseMappatura>
-----------------------------------------------
Coil
libreria per scaricare, caricare e utilizzare immagini
1)aggiungere le dipendenze nell app-level gradl:
		implementation("io.coil-kt:coil:1.4.0")
	nel project-level gradle ci deve essere mavencentral() dentro repositories{
		repositories{
			mavencentral()
2)'Binding Adapters'
- creare un FILE kotlin dove andare a inserire i metodi per i 'Binding Adapters'. es BindingAdapter.kt

'Binding Adapters' sono 'annotated methods' usati per creare 'setters' e 'properties' personalizzare per le viste (es ImageView nei leyout .xml)
con i 'Binding Adapters' si possono creare degli 'attributi' (es android:text) personalizzati, con delle logiche personalizzate, che vengono poi utilizzate dal 'Data binding' (es app:attributo="@{data.metodo()"}
in sostanza si vanno a creare degli attributi custom, es app:mioAttributo, e dei metodi annotati con @BindingAdapter("mioAttributo") che vengono richiamati quando il 'Data binding' va a settare quell'attributo.
- nell'annotazione @BindingAdapter("mioAttributo") va inserito il nome dell'attributo custom
- nel metodo che si va a creare (es. metodoPerAttributoCustom:
	il primo parametro è il TIPO di vista (quella che corrisponde alla vista dentro al layout xml in cui si va a settare l'attributo custom)
	il secondo parametro è il valore che viente settato sull'attributo
	@BindingAdapter("mioAttributo")
	fun metodoPerAttributoCustom( esTipoVista :ImageView, imgUrl: String?){
		..		
	}
	nota: String? perchè il valore può essere nullo. per questo dopo si usa il let chiamato sul safe call operator '?.'
2.1) 'let' (scope function)
	in Kotlin, la funzione let permette di eseguire del codice nel contesto di un oggetto. https://kotlinlang.org/docs/scope-functions.html
	può essere utilizzato per richiamare funzioni sul risultato di una concatenazione di funzioni, es:
	val numbers = mutableListOf("one", "two", "three", "four", "five")
		numbers.map { it.length }.filter { it > 3 }.let { 
			println(it)
			// and more function 
		} 
	richiamata con il safe call operator '?.', è eseguita solo se l'oggetto è NON nullo
3)dentro il metodo 'metodoPerAttributoCustom', dentro il let costruire un oggetto URL passando il tipo di schema (https)
	val imgUrl = stringaPassataCheContieneURL.toUri().buildUpon().scheme("https").build()
4)'COIL QUI!!' utilizzare il metodo load() della libreria 'Coil' che prende in input un oggetto Uri (costruito al punto 3)
	esTipoVistaImageView.load(imgUrl)
	nota: la Stringa di input del metodo deve essre settata come possibile nulla ovvero String? altrimenti va in null pointer
5)aggiungere un placeoder come immagine per a)caricamento b)errore nel caricamento dell'immagine, aggiungere un trail lambda al metodo load:
	esTipoVistaImageView.load(imgUrl){
		placeholder(R.drawable.chiaveIconaLoading)
		error(R.drawable.chiaveIconaErrore)
	}
-----------------------------------------------
Room
libreria per la persistenza in android
1)Aggiungere le dipendenze (NOTA: cercare la versione stabile piu aggiornata della libreria qui: https://developer.android.com/jetpack/androidx/versions)	
	nel build-level gradle, settare la versione dentro ext {
		ext {
			romm_version = "2.3.0"
	nel app-level gradle aggiungere la dipendenza:
		implementation "androidx.room:room-runtime:$room_version"
		kapt "androidx.room:room-compiler:$room_version"

		// optional - Kotlin Extensions and Coroutines support for Room
		implementation "androidx.room:room-ktx:$room_version"
2)"Entity" -Creare delle Entity per mappare le tabelle del DB (chiamate anche model classes, classi .kt), definendole come 'data class NomeClasseEntity ('
	-Annotare la data class come @Entity specificando il nome in caso sia diverso da quello dalla tabella a DB
		@Entity(tableName = "nome_tabella_db")
		data class NomeClasseEntity(
		..
		)
	-All'interno definire una property annotata come chiave primaria @PrimaryKey(autoGererate = true) con argomento autoGererate per fare genrerare a Room la chiave automaticamente
	(NOTA la , dopo la property - nelle classi data le property sono separate da ,):
		@PrimaryKey(autoGererate = true)
		val id: Int,
	per ogni colonna aggiungere una property, specificando:
	a) @ColumnInfo(name = 'nome_colonna_db') per mappare la property con la colonna della tabella (in caso di nomi diversi)
	b) @NotNull se si vuole che la colonna non ammetta valori nulli
	c) tipo del dato, es String
		@NotNull @ColumnInfo(name = 'nome_colonna_db')
		val nomePropertyColonnaDb: String,
	-".copy(..)" - NOTA: le una classe 'data class' ha un metodo .copy() che permette di creare una nuova istanza della classe con gli stessi valori dell'oggetto su cui si richiama il metodo copy, tranne per quelli che vengono riderfiniti dentro la parentesi
		.copy(propertyDaCambiare = nuovo valore)
3)"DAO"-Creare una interfaccia DAO (data acces object) che definisce le funzioni con cui poter accedere al DB,annotarla con @Dao 
		@Dao
		interface NomeTabellaDao {
			...
		}
	-Definire i metodi per accedere al DB definendo con l'annotazione @Query la query da fare a DB
	 The database operations can take a long time to execute, so they should run on a separate thread. Make the function a suspend function
		(dubbio: suspend va utilizzato con gli operatori di default come @Insert, @Update, @Delete
		mentre con le @Query 'normali' non è necessario????)
		@Query("select * from table_name where column_name = :parapetroPassato order by column_name asc")
		fun nomeFunzioneParlante(parametroPassato :String): List<NomeClasseEntity>
	utilizzando un annotazione @Insert, si può utilizzare un argomento 'onConflict' per definire cosa fare in caso esista già la primary key (chiave duplicata)
		@Insert(onConflict = OnConflictStrategy.IGNORE)
		suspend fun insertItem(item: Item)
4)"ViewModel"-creare una classe di tipo :ViewModel con cui accedere ai metodi definiti nel interfaccia DAO. passare nel costruttore il parametro di tipo interefaccia DAO
		class NomeClasseViewModel(private val interfacciaNomeTabellaDao :NomeTabellaDao) :ViewModel(){ ..
	-definire dei metodi che richiamano i metodi del DAO, in kotlin è possibile usare una forma abbraviata come segue:
		fun nomeMetodo(parametro :Tipo): List<TipoDiRitorno> = interfacciaNomeTabellaDao.metodoDao(parametro)
5)"Factory"-creare una 'factory' per l'oggetto viewModel. lo scopo è fare creare la viewModel da un ogetto 'lifecycle aware' (boh!)
	creare la classe che implementa : ViewModelProvider.Factory
	la factory può essere creata nello stesso file .kt della classe viewModel
		class NomeClasseViewModelFactory(private val interfacciaNomeTabellaDao: NomeTabellaDao) : ViewModelProvider.Factory { ..
	
	fare l'override del metodo create() che ritorna la classe di tipo ViewModel passando il parametro DAO nel costruttore:
		override fun <T : ViewModel> create(modelClass: Class<T>): T {
		   if (modelClass.isAssignableFrom(NomeClasseViewModel::class.java)) {
			   @Suppress("UNCHECKED_CAST")
			   return NomeClasseViewModel(interfacciaNomeTabellaDao) as T
		   }
		   throw IllegalArgumentException("Unknown ViewModel class")
   }
6)"AppDatabase"-creare una classe AppDatabase (o chiamarla come si vuole) che implementa RoomDatabase()
	lo scopo di questa classe è di a)specificare quali Entity definire nel DB b)fornire un istanza delle interfacce DAO c)fare i setup iniziali, come pre popolare il DB
	-creare una classe astratta AppDatabase che eredita da RoomDatabase
		abstract class AppDatabase: RoomDatabase() {..
	-creare una funzione astratta che ritorna un oggetto di tipo "NomeTabellaDao"
		abstract fun nomeTabellaDao(): NomeTabellaDao
	-creare un "companion object" per far in modo tale che una e solo una istanza del DB venga creata, usando un metodo che ritorna una nuova istanza solo se non esiste
		companion object {..
	-aggiungere un istanza chiamata 'INSTANCE' di tipo AppDatabase. a)il valore è inizialmente null, quindi settarlo con '?' b)usare l'annotazione @Volatile
		@Volatile
		private var INSTANCE: AppDatabase? = null
	-implementare la funzione 'getDatabase(context: Context): AppDatabase{' che usa un Elvis operator per restituire l'istanza del DB se esiste già altrimenti la crea
		si utilizza synchronized in modo tale che solo un thread alla volta possa accedere al blocco di codice e quindi non si rischia di avere due istanze del DB
		NOTA BENE: al posto di scrivere 'return instance' si poteva scrivere 'instance' omettendo il 'return' che è sottointeso
		il 'migration object' definisce come predere i record della versione del vecchio schema e metterli nel nuovo schema (modificato) 
		per eliminare il DB e rifarlo quando lo schema viene modificato richiamare '.fallbackToDestructiveMigration()'
		
		fun getDatabase(context: Context): AppDatabase {
			return INSTANCE ?: synchronized(this) {
				val instance = Room.databaseBuilder(
					context.applicationContext,
					AppDatabase::class.java,
					"app_database")
					.createFromAsset("database/bus_schedule.db")
					.fallbackToDestructiveMigration()
					.build()
				INSTANCE = instance

				return instance
			}
		}
	-la classe astratta 'AppDatabase' deve essere annotata con @Database in cui vengono specificate tutte le Entity
	la version va incrementata ad ogni modifica dello schema, cosi Room va ad applicare le modifiche al DB
		@Database(entities = arrayOf(ClasseEntity1::class, ClasseEntity2::class), version = 1)
		dopo 'version 1' si può aggiungere la proprietà 'exportSchema = false' in modo che non venga fatto il bkp della versione dello schema
7)"Application"-Creare una classe .kt (es. NomeParalteApplication) che eredita dalla classe :Application()
	aggiungere una property 'database' di tipo 'AppDatabase' (definita al punto 6)) e istanziarla by lazy (perchè creare il DB è un operazione costosa):
		calss NomeParalteApplication: Application() {
			val database: AppDatabase() by lazy { AppDatabase.getDatabase(this) }
8)"AndroidManifest.xml"-Modificare la property <application nel file AndroidManifest.xml in modo tale che punti al estensione fatta  'NomeParalteApplication' della classe Application:
		<application
			android:name="com.example.busschedule.NomeParalteApplication"
9)"instanziare la classe ViewModel" dentro un fragment, per avere il reference della classe NomeClasseViewModel fare
	private val vievModel: NomeClasseViewModel by activityViewModels {
			NomeClasseViewModelFactory(
				(activity?.application as NomeParalteApplication).database.nomeTabellaDao()
			)
		}
10)"assegnare l'adapter al recyclerView" dentro il metodo onViewCreated(..), creare un istanza del adapter, passando come parametro la 'lambda expression' da richiamare sul 'onItemClicked'
	assegnare l'istanza del adapter alla recyclerView.adapter
		val nomeParlanteAdapter = NomeParalteAdapter({
		   val action = NomeClasseFragmentDirections.actionFragmentPartenzaToFragmentDestinazione(
			   parametroFragmetnAction = it.paramentroDaPassare
		   )
		   view.findNavController().navigate(action)
		})
		recyclerView.adapter = nomeParlanteAdapter
11)"Flow" implementare il concetto di 'asynchronous flow' che peremtte al DAO di emettere dati dal DB in modo continuativo.
	la libreria 'Room' implementa già i Flow, ovvero le query possono restituire oggetti Flow, quindi è sufficiente cambiare il tipo di dato di ritorno wrappandoli in degli oggetti flow
	-dantro il DAO modificare:
		'fun nomeFunzioneParlante(parametroPassato :String): Flow<List<NomeClasseEntity>>' (prima era List<NomeClasseEntity>)
	-nella classe ViewModel, modificare il tipo di ritorno dei metodi che richiamano il DAO
		fun nomeMetodo(parametro :Tipo): Flow<List<NomeClasseEntity>> = interfacciaNomeTabellaDao.metodoDao(parametro)
	-(es dentro un fragment) per accedere al valore restituito dal ViewModel (che richiama il DAO), richiamare il metodo collect(){..} sul ogetto Flow
		viewModel.nomeMetodoCheRichiamaIlDaoERestituisceIlFlow(eventaleParametro).collect() { nomeaAdapter.submitList(it) }  --dove 'it' è l'oggetto wrappato nel oggetto flow il quale appunto può cambiare valore
	 i metodi di accesso al DB sono 'suspended' (?) per questo vanno richiamati dentro una 'coroutine': 
		lifecycle.coroutineScope.launch { ..
	 mettendo tutto assieme:
		lifecycle.coroutineScope.launch {
			viewModel.nomeMetodoCheRichiamaIlDaoERestituisceIlFlow(eventaleParametro).collect() {
				nomeaAdapter.submitList(it) 
			}
		}
	-se si accede al DAO da viewModel, per lanciare le funzioni 'suspend' (tutte..? quelle annotate con @Query non serve?) che si relazionano con il DB, utilizzare viewModelScope.launch { ..richiamo alla fun del DAO ..}
	
	-se nel viewModel si trasforma il Flow in LiveData tramite il metodo .asLiveData(), dentro un fragment per accedere ai valori del LiveData utilizzare il metodo .observe(this.viewLifecycleOwner) {..}
	e nella lambda expression si definisce come parametro il valore wrappato nel livedata, dopo il simbolo -> sul parametro si richiama il metodo .let{..} e si definisce la lambda expression dove il parametro sottointeseo è sempre il valore wrappato nel livedata:
	es:
		viewModel.allItems.observe(this.viewLifecycleOwner) {items ->
				items.let{
					adapter.submitList(it)
				}
			}
-----------------------------------------------
"Extensions"
in Kotlin ability to extend a class with new functionality without having to inherit from the class or modify the existing definition of the class
'extension functions' e 'extension properties'
le extension function possono essere richiamate con il 'punto' sull'istanza della classe
definizione extension function:
	calss NomeClasse() {
	..
	}
	fun NomeClasse.nomeFunzioneExtension() {
	..
	}
richiamo extension function:
	val nomeOggetto = NomeClasse()
	nomeOggetto.nomeFunzioneExtension()
-----------------------------------------------
"DataStore"
'Preferences DataStore' accesses and stores data based on keys, without defining a schema (database model) upfront.
'Proto DataStore' defines the schema using Protocol buffers. Using Protocol buffers, or Protobufs, lets you persist strongly typed data. Protobufs are faster, smaller, simpler, and less ambiguous than XML and other similar data formats.
1)aggiungere le dipendeze nel app-level build.gradle
	implementation "androidx.datastore:datastore-preferences:1.0.0"
	implementation "androidx.lifecycle:lifecycle-livedata-ktx:2.3.1"
2)-'SettingsDataSotre'-creare un file .kt SettingsDataSotre dentro il pkg data
	-creare una classe SettingsDataSotre che prende come parametro in oggetto Context
		class SettingsDataSotre(context: Context){}
	-sopra la classe creare un a costante:
		private const val LAYOUT_PREFERENCES_NAME = "layout_preferences"
	-sopra la classe, creare un istanza di DataStore utilizzando il 'preferencesDataStore delegate'
	si sta utilizzando il 'Preferences Datastore' quindi si passa 'Preferences'
	settare il 'name' con la costante LAYOUT_PREFERENCES_NAME
		private val Context.datastore : DataStore<Preferences> bu preferencesDataStore (
			name = LAYOUT_PREFERENCES_NAME
		)
3)'SettingsDataSotre'- implementazione della classe
	-definire le 'chaivi - valore'
	i valori da salvare nell'istanza di DataStore<Preferences> sono creati settando delle property, ovvero delle chiavi con cui poi si recupera il valore, tramite le funzioni (già definite) 'tipoValorePreferenceKey("")' es: 
	intPreferencesKey(), stringPreferencesKey(), booleanPreferenceKey() - dove il tipo corrisponde al tipo di dato (property) che si vuole associare a quella chiave.
	es per settare una chiave a cui corrisponde un dato di tipo Boolean usare:
			'private val NOME_PROPERTY_CHIAVE = booleanPreferenceKey("nome_property")'
	-definire i metodi per salvare i valori associati alle chiavi
	per ogni chiave definita, definire una funzione 'suspend' con le seguenti caratteristiche
		prende in input a)il contesto 'context: Context' e b) il dato associato alla chiave da salvare 'datoDaSalvare: tipoSettatoNellaChiave'
		richiama il metodo '.edit' del oggetto dataStore: context.dataStore.edit {
		la lambda expression ha come parametro di input un oggetto 'preferences'
		dentro la lambda si associa il valore alla chiave tramite l'espressione preferences[NOME_PROPERTY_CHIAVE] = datoDaSalvare
			suspend fun savePropertyToPreferencesStore(datoDaSalvare: Boolean, context: Context){
				context.dataStore.edit {    preferences ->
					preferences[NOME_PROPERTY_CHIAVE] = datoDaSalvare
				}
			}
	-leggere i valori salvati a DB
	per ogni valore salvato nel DB DataStore, estrarre un Flow che contiene il valore e salvarlo in una variabile.
	per fare cio si utilizza il metodo .map sul Flow che contiene un oggetto 'preference' (contentente tutte le copie chiavi-valori salvati)
	al il Flow<preferences> si accede tramite context.dataStore.data. (notere l'elvis operator perchè all'inizio non è c'è ancora salvato nessun dato e si restituisce il valore di dafault)
		 val preferenceFlowDatoDaLeggere: Flow<TipoDatoSalvato> = context.dataStore.data.map {
			preferences -> preferences[NOME_PROPERTY_CHIAVE] ?: valoreDefault
		 }
	-gestione eccezioni
	richiamare il mentodo '.map' sul 'context.datastore.data' può lanciare una 'IOException'. prima di richiamare il metodo .map, utilizzare il .catch{}
	dentro il 'catch' verificare se l'eccezione è di tipo IOException e restituire un emptyPreference(). altrimenti lanciare l'ecezione
	..context.dataStore.data
		.catch {
			if (it is IOException){
					it.printStackTrace()
					emit(emptyPreferences())
				} else {
					throw it
				}
		}
		.map{ ..
4)'Utilizzare SettingsDataSotre'
	-dentro un fragment creare una variabile lateinit di SettingsDataSotre
		private lateinit var SettingsDataSotre: SettingsDataSotre
	-in fondo al metodo onViewCreated() inizializzare la variabile passando requiredContext():
		SettingsDataSotre = SettingsDataSotre(this.requiredContext())
	-leggere le variabili salvate dentro SettingsDataSotre trasformandole da Flow a LiveData
		SettingsDataSotre.preferenceFlowDatoDaLeggere.asLiveData().observe(this.lifecycleOwner) {
			..operazioni da fare con il 'dato da leggere'..
		}
	-la funzione per il salvataggio 'savePropertyToPreferencesStore' definita dentro SettingsDataSotre è 'suspend' quindi deve essere richiamata dentro una coroutine
	i 'fragment' sono 'Lifecycle-aware components' e forniscono un oggetto 'LifecycleScope' con cui è possibile lanciare coroutine.
	le coroutine lanciate con 'LifecycleScope' sono 'canceled' quando il 'lifecycle owner' è distrutto
	per salvare i dati lanciare la coroutine e richiamare la funzione:
	lifecycleScope.launch {
		SettingsDataSotre.savePropertyToPreferencesStore(datoDaSalvare, requireContext())
	}		
-----------------------------------------------
'WorkManager'-> libreria per il 'deferrable background work' in android
serve per tasks che devono essere completati anche se l'applicazione non è in primo piano
0)elementi principali:
	-'Worker' la classe da estendere in cui mettere il codice da eseguire nel work il background.
		si fa l'override del metodo doWork()
	-'WorkRequest': rappresenta la richiesta per eseguire dei work. nella 'WorkRequest' sono settati
		a)i worker da eseguire b)i 'constraints' della 'WorkRequest'
		Ci sono due tipi di WorkRequest:
		OneTimeWorkRequest: una WorkRequest che viene eseguita solo una volta
		PeriodicWorkRequest: una WorkRequest che viene eseguita ciclicamente
	-'WorkManager':la classe che schedula la 'WorkRequest' e la fa girare
1)'build.gradle dependencies'
	nel app level build.gradle aggiungere la dependency:
		implementation "androidx.work:work-runtime-ktx:$versions.work
2)'Worker'
	-creare una classe 'ClasseWorker' che estende 'Worker'.
	-definire il costruttore con due paramentri, a) di tipo Context b) di tipo 'WorkerParameters' e passarli al costruttore del WorkerParameters	
		class ClasseWorker(context: Context, param: WorkerParameters) : Worker(context,param){
	-fare l'overraid del metodo 'doWork()'
	Pentro una classe che estende 'Worker' è possibile utilizzare il metodo 'makeStatuNotification()' per mostrare un banner a schermo
	Per avere un istanza del 'context' è possibile utilizzare 'applicationContext': val appContext = applicationContext
	Mettere il codice dentro un blocco try { } catch (e: Throwable) { }
	Restituire Result.success() (o Result.faliure() dentro il blocco catch)
3)'WorkManager in vievModel'
	All'interno di viewModel creare un istanza di 'WorkManager' richiamando il metodo 'getInstance()' passando un istanza di 'Application' (che viene passata al costruttore del viewModel dal 'activity' in cui viene reuperata dalla classe madre 'Activity' semplicemente scrivendo 'application'
		private val workManager = WorkManager.getInstance(application)
	a)'WorkRequest': All'intenro della funzione nella quale si vuole lanciare il Worker, creare un istanza di WorkRequest richiamando il metodo 'from()' su 'OneTimeWorkRequest' e passando il tipo della classe
		val oneTimeWorkRequest = OneTimeWorkRequest.from(ClasseWorker::class.java)
	Lanciare l'attività richiamando il metodo 'enqueue()' sul 'WorkManager' e passando come parametro 'oneTimeWorkRequest'
		WorkManager.enqueue(oneTimeWorkRequest)
	'Data object'
	i 'Data object' sono contenitori per coppie key/value
	sono pensati per contenere piccoli quantità di dati da passare dentro una 'WorkRequest'
		val builder = Data.Builder()
		builder.putString("CHIAVE","stringa da inserire")
		data = builder.build()
	b)'WorkRequest': Un altro modo per creare una 'WorkRequest' è attraverso il OneTimeWorkManagerBuilder.
	si posso passare 'Data object' tramite il metodo setInputData()
	per costruire la 'WorkRequest' richiamare il metodo build()
		val workRequest = OneTimeWorkManagerBuilder<ClasseWorker>().setInputData(data).build()
	Dentro la 'classeWorker', per recuperare il 'Data object', richiamare il metodo getString(CHIAVE)
		val stringaVal = data.getString(CHIAVE)
	Per restituire valori dalla 'ClasseWorker' passare un 'Data object' nel metodo success.
	creare il 'Data object' tamite il metdoto morkDataOf()
		val outputData = workDataOf(CHIAVE to "stringa da passare")
		Result.success(outputData)
-----------------------------------------------
to do: appunti su adapter





wtf  DataProviderManager is?